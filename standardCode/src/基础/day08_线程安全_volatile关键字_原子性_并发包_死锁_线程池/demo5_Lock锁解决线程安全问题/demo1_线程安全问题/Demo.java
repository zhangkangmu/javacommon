package 基础.day08_线程安全_volatile关键字_原子性_并发包_死锁_线程池.demo5_Lock锁解决线程安全问题.demo1_线程安全问题;

/**
 * @author 彭智林
 * @date 2019/12/25 8:50
 */
public class Demo {
    public static void main(String[] args) {
        /*
            线程安全:
                如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。
                程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。

            案例: 多线程模拟4个窗口共同出售100张火车票
            分析:
                1.4个窗口共同出售100张火车票   火车票总共有100张
                2.4个窗口                    4条线程
            思路:
                1.创建Runnable的实现类
                2.在实现类中重写run()方法,把线程需要执行的代码放入run()方法中
                3.创建实现类对象
                4.创建Thread线程对象,传入实现类对象
                5.使用线程对象调用start()方法,启动线程,执行任务
            卖票的案例线程安全:只能卖100张票,不会出现重复票,不会少卖某张票,不会出售负数票
            卖票的案例线程不安全: 出现卖重复票,少卖票,出现负数票

            分析为什么会出现线程不安全问题:
                    线程正在卖票的时候,会被其他线程打断,从而执行其他线程的任务,修改共享变量的值,
                    导致数据出现不安全,也就是出现线程安全问题

            解决卖票案例线程不安全问题: 一条线程在卖票,不允许其他线程打断
            也就是说:假设窗口1在卖票,窗口2,窗口3,窗口4只能在外面等着,只有
                    等窗口1卖完了一张票,才可以去抢cpu来卖票

            使用同步机制解决线程安全问题:
                同步代码块
                同步方法
                Lock锁
         */
        // 创建实现类对象
        MyRunnable mr = new MyRunnable();

        // 创建Thread线程对象,传入实现类对象,使用线程对象调用start()方法,启动线程,执行任务
        new Thread(mr,"窗口1").start();
        new Thread(mr,"窗口2").start();
        new Thread(mr,"窗口3").start();
        new Thread(mr,"窗口4").start();
    }
}
